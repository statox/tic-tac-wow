const A=e=>{const t=e===1?1:-1,r=[1,1,2,2,3,3].map(o=>o*t);return{player:e,pieces:r,unselectableIndexes:new Set,selectedPiece:null}},K=e=>{const t=[];for(let o=0;o<3;o++){t.push([]);for(let n=0;n<3;n++)t[t.length-1].push([])}const r={state:{player:1,action:"select1"},grid:t,player1:A(1),player2:A(2),historyEnabled:(e==null?void 0:e.historyEnabled)||!1,history:[]};return e!=null&&e.player2Start&&(r.state.player=2),r},_=e=>{const t=e.player1.unselectableIndexes,r=e.player2.unselectableIndexes,o=JSON.parse(JSON.stringify(e));return o.player1.unselectableIndexes=new Set([...t.values()]),o.player2.unselectableIndexes=new Set([...r.values()]),o},h=e=>e.state.player===1?e.player1:e.player2,v=e=>e.state.player===1?e.player2:e.player1,H=(e,t)=>t?e.grid.map(r=>r.map(o=>o.join(",")).join("	|")).join(`
`):e.grid.map(r=>r.map(o=>o.join(",")).join("	|")).join(`
`),T=(e,t,r)=>{t&&console.log(t),console.log(H(e,r)),console.log()},j=(e,t)=>{const r=[];for(const o of[e.player1,e.player2]){if(t){r.push(`P${o.player}: `+o.pieces.filter((n,s)=>!o.unselectableIndexes.has(s)).join(", ")),r.push("selection: "+JSON.stringify(o.selectedPiece)),r.push("already used: "+[...o.unselectableIndexes.values()].join(","));continue}r.push(`P${o.player}: `+o.pieces.join(", "))}return r.join(`
`)},$=(e,t,r)=>{t&&console.log(t),console.log(j(e,r)),console.log()},Q=(e,t)=>{t&&console.log(t),console.log("State:",e.state.action,e.state.player),T(e,"",!0),$(e,"",!0)},C=(e,t,r)=>{const o=e[r][t];return o.length?o[o.length-1]:null},d=(e,t,r)=>{if(t<0||r<0||t>2||r>2)throw new Error(`Invalid coordinates ${t},${r}`);const o=C(e,t,r);return o===null?null:o>0?1:2},R=(e,t,r)=>{if(t<0||r<0||t>2||r>2)throw new Error(`Invalid coordinates ${t},${r}`);const o=C(e,t,r);return o===null?0:Math.abs(o)},E=(e,t,r)=>{const o=d(e,t.x,t.y),n=d(e,r.x,r.y);return o!==null&&o===n},x=e=>{const{grid:t}=e,r=new Set;for(let o=0;o<3;o++)if(E(t,{x:0,y:o},{x:1,y:o})&&E(t,{x:0,y:o},{x:2,y:o})){const n=d(t,0,o);r.add(n)}for(let o=0;o<3;o++)if(E(t,{x:o,y:0},{x:o,y:1})&&E(t,{x:o,y:0},{x:o,y:2})){const n=d(t,o,0);r.add(n)}if(E(t,{x:0,y:0},{x:1,y:1})&&E(t,{x:0,y:0},{x:2,y:2})){const o=d(t,0,0);r.add(o)}if(E(t,{x:0,y:2},{x:1,y:1})&&E(t,{x:0,y:2},{x:2,y:0})){const o=d(t,0,2);r.add(o)}if(r.delete(null),r.size===1){e.state.player=[...r.values()][0],e.state.action="winner";return}if(r.size===2){e.state.player=1,e.state.action="draw";return}},X=(e,t,r)=>{if(e.state.player!==t.player||e.state.action!=="select1")throw new Error("invalid_step");if(r>=t.pieces.length||r<0)throw new Error("oob_selection_index");if(t.selectedPiece!==null)throw new Error("previous_selection_in_hand");if(t.unselectableIndexes.has(r))throw new Error("piece_already_used");t.selectedPiece={from:"hand",index:r},e.state.action="select2"},O=(e,t,r)=>{if(e.state.player!==t.player||e.state.action!=="select1")throw new Error("invalid_step");const{x:o,y:n}=r;if(o<0||n<0||o>2||n>2)throw new Error(`Invalid coordinates ${o},${n}`);if(t.selectedPiece!==null)throw new Error("previous_selection_in_hand");if(e.grid[n][o].length===0)throw new Error("empty_stack_selection");if(d(e.grid,o,n)!==t.player)throw new Error("opponent_owned_selection");t.selectedPiece={from:"board",position:{x:o,y:n}},e.state.action="select2"},B=(e,t)=>{if(e.state.action!=="select2")throw new Error("invalid_step");const r=h(e);if(r.selectedPiece===null)throw new Error("no_selection_in_hand");const{x:o,y:n}=t,s={...r.selectedPiece},c=s.from==="hand"?r.pieces[s.index]:C(e.grid,s.position.x,s.position.y);if(c===null)throw new Error("selected_piece_is_null");if(R(e.grid,o,n)>=Math.abs(c))throw new Error("destination_bigger_than_piece");return e.grid[t.y][t.x].push(c),s.from==="hand"&&r.unselectableIndexes.add(s.index),s.from==="board"&&e.grid[s.position.y][s.position.x].pop(),r.selectedPiece=null,e.state.action="select1",e.state.player=e.state.player===1?2:1,x(e),e.historyEnabled&&e.history.push({move:{from:s,to:t},state:{...e.state}}),0},p=(e,t,r)=>{r.from.from==="hand"?X(e,t,r.from.index):O(e,t,r.from.position),B(e,r.to)},J=(e,t)=>{const r=[];for(let o=0;o<3;o++)for(let n=0;n<3;n++){const s=R(e.grid,n,o);(!s||s<Math.abs(t))&&r.push({x:n,y:o})}return r},w=(e,t)=>L(e,t).reduce((o,n)=>{const s=P(e,t,n),c=J(e,s);for(const i of c)o.push({from:n,to:i});return o},[]),L=(e,t)=>{const r=t.pieces.map((o,n)=>n).filter(o=>!(t.unselectableIndexes.has(o)||o===1&&!t.unselectableIndexes.has(0)||o===3&&!t.unselectableIndexes.has(2)||o===5&&!t.unselectableIndexes.has(4))).map(o=>({index:o,from:"hand"}));for(let o=0;o<3;o++)for(let n=0;n<3;n++)d(e.grid,n,o)===t.player&&r.push({from:"board",position:{x:n,y:o}});return r},P=(e,t,r)=>{if(r.from==="board"){const o=e.grid[r.position.y][r.position.x];return o[o.length-1]}return t.pieces[r.index]},m=e=>{if(x(e),e.state.action==="winner")return e.state.player===1?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER;if(e.state.action==="draw")return Number.MAX_SAFE_INTEGER/2;const t=w(e,e.player1),r=w(e,e.player2);if(t.length===0&&r.length===0)return Number.MAX_SAFE_INTEGER/2;let o=0;const n=d(e.grid,1,1);return n===e.player1.player?o+=2:n===e.player2.player&&(o-=2),[d(e.grid,0,0),d(e.grid,2,0),d(e.grid,0,2),d(e.grid,2,2)].forEach(c=>{c!==null&&(o+=c!==null&&c===1?1:-1)}),o},G=(e,t,r)=>{let o=0;r.from.from==="board"&&(o+=10);const n=P(e,t,r.from);return o+=Math.abs(n),r.to.x===1&&r.to.y===1&&(o+=5),(r.to.x===0&&r.to.y===0||r.to.x===2&&r.to.y===0||r.to.x===0&&r.to.y===2||r.to.x===2&&r.to.y===2)&&(o+=3),o},N=(e,t,r,o,n)=>{const s=w(e,t);if(x(e),r===0||!s.length||["draw","winner"].includes(e.state.action))return{score:m(e),move:null};if(t.player===1){let l=Number.MIN_SAFE_INTEGER,a;for(const u of s){const f=_(e),y=h(f),M=v(f);p(f,y,u);const b=N(f,M,r-1,o,n);if((l===void 0||b.score>=l)&&(l=b.score,a={score:b.score,move:u}),l>n)break;o=Math.max(o,l)}if(!a)throw new Error("no_minmax_result");return a}let c=Number.MAX_SAFE_INTEGER,i;for(const l of s){const a=_(e),u=h(a),f=v(a);p(a,u,l);const y=N(a,f,r-1,o,n);if((c===void 0||y.score<=c)&&(c=y.score,i={score:y.score,move:l}),c<o)break;n=Math.min(n,c)}if(!i)throw new Error("no_minmax_result");return i},z=(e,t)=>{const r=N(e,t,3,Number.MIN_SAFE_INTEGER,Number.MAX_SAFE_INTEGER);if(!r.move)throw new Error("no_move_possible");const o=r.move;p(e,t,o)},I=(e,t,r,o,n)=>{const s=w(e,t);if(x(e),r===0||!s.length||["draw","winner"].includes(e.state.action))return{score:m(e),move:null};if(s.sort((l,a)=>G(e,t,a)-G(e,t,l)),t.player===1){let l=Number.MIN_SAFE_INTEGER,a;for(const u of s){const f=_(e),y=h(f),M=v(f);p(f,y,u);const b=I(f,M,r-1,o,n);if((l===void 0||b.score>=l)&&(l=b.score,a={score:b.score,move:u}),l>n)break;o=Math.max(o,l)}if(!a)throw new Error("no_minmax_result");return a}let c=Number.MAX_SAFE_INTEGER,i;for(const l of s){const a=_(e),u=h(a),f=v(a);p(a,u,l);const y=I(a,f,r-1,o,n);if((c===void 0||y.score<=c)&&(c=y.score,i={score:y.score,move:l}),c<o)break;n=Math.min(n,c)}if(!i)throw new Error("no_minmax_result");return i},U=(e,t)=>{const r=I(e,t,4,Number.MIN_SAFE_INTEGER,Number.MAX_SAFE_INTEGER);if(!r.move)throw new Error("no_move_possible");const o=r.move;p(e,t,o)},V=(e,t)=>{const r=w(e,t);if(!r.length)throw new Error("no_move_possible");const s=[...r.reduce((c,i)=>{const l=_(e),a=t.player===1?l.player1:l.player2;p(l,a,i);const u=m(l);return c.push({move:i,score:u}),c},[])].sort((c,i)=>t.player===1?i.score-c.score:c.score-i.score)[0].move;p(e,t,s)},S=(e,t,r)=>{const o=w(e,t);if(x(e),r===0||!o.length||["draw","winner"].includes(e.state.action))return{score:m(e),move:null};if(t.player===1){let n=Number.MIN_SAFE_INTEGER,s;for(const c of o){const i=_(e),l=h(i),a=v(i);p(i,l,c);const u=S(i,a,r-1);(n===void 0||u.score>=n)&&(n=u.score,s={score:u.score,move:c})}if(!s)throw new Error("no_minmax_result");return s}else{let n=Number.MAX_SAFE_INTEGER,s;for(const c of o){const i=_(e),l=h(i),a=v(i);p(i,l,c);const u=S(i,a,r-1);(n===void 0||u.score<=n)&&(n=u.score,s={score:u.score,move:c})}if(!s)throw new Error("no_minmax_result");return s}},W=(e,t)=>{const r=S(e,t,2);if(!r.move)throw new Error("no_move_possible");const o=r.move;p(e,t,o)},F=(e,t,r)=>{const o=t.player===1?1:-1,n=w(e,t);if(x(e),r===0||!n.length||["draw","winner"].includes(e.state.action))return{score:m(e)*o,move:null};let s=Number.MIN_SAFE_INTEGER,c;for(const i of n){const l=_(e),a=h(l),u=v(l);p(l,a,i);const f=F(l,u,r-1);f.score=-f.score,(s===void 0||f.score>=s)&&(s=f.score,c={score:f.score,move:i})}if(!c)throw new Error("no_minmax_result");return c},q=(e,t)=>{const r=F(e,t,2);if(!r.move)throw new Error("no_move_possible");const o=r.move;p(e,t,o)},k=(e,t)=>{const r=w(e,t);if(r.length===0)throw new Error("no_move_possible");const o=Math.floor(Math.random()*r.length),n=r[o];p(e,t,n)},D=(e,t)=>{const r=w(e,t);if(!r.length)throw new Error("no_move_possible");for(const o of r){const n=_(e),s=t.player===1?n.player1:n.player2;if(p(n,s,o),x(n),n.state.action==="winner"&&n.state.player===t.player){p(e,t,o);return}}k(e,t)},Y={random:k,win_or_random:D,euristic:V,minmax:W,negamax:q,alphabeta:z,alphabeta_ordered:U};export{h as a,v as b,O as c,X as d,x as e,T as f,K as g,$ as h,Q as i,B as p,Y as s};
