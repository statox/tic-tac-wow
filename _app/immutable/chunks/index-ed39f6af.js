const C=e=>{const r=e===1?1:-1,o=[1,1,2,2,3,3].map(t=>t*r);return{player:e,pieces:o,unselectableIndexes:new Set,selectedPiece:null}},K=e=>{const r=[];for(let t=0;t<3;t++){r.push([]);for(let s=0;s<3;s++)r[r.length-1].push([])}const o={state:{player:1,action:"select1"},grid:r,player1:C(1),player2:C(2)};return e!=null&&e.player2Start&&(o.state.player=2),o},_=e=>{const r=e.player1.unselectableIndexes,o=e.player2.unselectableIndexes,t=JSON.parse(JSON.stringify(e));return t.player1.unselectableIndexes=new Set([...r.values()]),t.player2.unselectableIndexes=new Set([...o.values()]),t},v=e=>e.state.player===1?e.player1:e.player2,h=e=>e.state.player===1?e.player2:e.player1,H=(e,r)=>r?e.grid.map(o=>o.map(t=>t.join(",")).join("	|")).join(`
`):e.grid.map(o=>o.map(t=>t.join(",")).join("	|")).join(`
`),T=(e,r,o)=>{r&&console.log(r),console.log(H(e,o)),console.log()},j=(e,r)=>{const o=[];for(const t of[e.player1,e.player2]){if(r){o.push(`P${t.player}: `+t.pieces.filter((s,n)=>!t.unselectableIndexes.has(n)).join(", ")),o.push("selection: "+JSON.stringify(t.selectedPiece)),o.push("already used: "+[...t.unselectableIndexes.values()].join(","));continue}o.push(`P${t.player}: `+t.pieces.join(", "))}return o.join(`
`)},$=(e,r,o)=>{r&&console.log(r),console.log(j(e,o)),console.log()},Q=(e,r)=>{r&&console.log(r),console.log("State:",e.state.action,e.state.player),T(e,"",!0),$(e,"",!0)},P=(e,r,o)=>{const t=e[o][r];return t.length?t[t.length-1]:null},d=(e,r,o)=>{if(r<0||o<0||r>2||o>2)throw new Error(`Invalid coordinates ${r},${o}`);const t=P(e,r,o);return t===null?null:t>0?1:2},G=(e,r,o)=>{if(r<0||o<0||r>2||o>2)throw new Error(`Invalid coordinates ${r},${o}`);const t=P(e,r,o);return t===null?0:Math.abs(t)},E=(e,r,o)=>{const t=d(e,r.x,r.y),s=d(e,o.x,o.y);return t!==null&&t===s},x=e=>{const{grid:r}=e,o=new Set;for(let t=0;t<3;t++)if(E(r,{x:0,y:t},{x:1,y:t})&&E(r,{x:0,y:t},{x:2,y:t})){const s=d(r,0,t);o.add(s)}for(let t=0;t<3;t++)if(E(r,{x:t,y:0},{x:t,y:1})&&E(r,{x:t,y:0},{x:t,y:2})){const s=d(r,t,0);o.add(s)}if(E(r,{x:0,y:0},{x:1,y:1})&&E(r,{x:0,y:0},{x:2,y:2})){const t=d(r,0,0);o.add(t)}if(E(r,{x:0,y:2},{x:1,y:1})&&E(r,{x:0,y:2},{x:2,y:0})){const t=d(r,0,2);o.add(t)}if(o.delete(null),o.size===1){e.state.player=[...o.values()][0],e.state.action="winner";return}if(o.size===2){e.state.player=1,e.state.action="draw";return}},X=(e,r,o)=>{if(e.state.player!==r.player||e.state.action!=="select1")throw new Error("invalid_step");if(o>=r.pieces.length||o<0)throw new Error("oob_selection_index");if(r.selectedPiece!==null)throw new Error("previous_selection_in_hand");if(r.unselectableIndexes.has(o))throw new Error("piece_already_used");r.selectedPiece={from:"hand",index:o},e.state.action="select2"},O=(e,r,o)=>{if(e.state.player!==r.player||e.state.action!=="select1")throw new Error("invalid_step");const{x:t,y:s}=o;if(t<0||s<0||t>2||s>2)throw new Error(`Invalid coordinates ${t},${s}`);if(r.selectedPiece!==null)throw new Error("previous_selection_in_hand");if(e.grid[s][t].length===0)throw new Error("empty_stack_selection");if(d(e.grid,t,s)!==r.player)throw new Error("opponent_owned_selection");r.selectedPiece={from:"board",position:{x:t,y:s}},e.state.action="select2"},B=(e,r)=>{if(e.state.action!=="select2")throw new Error("invalid_step");const o=v(e);if(o.selectedPiece===null)throw new Error("no_selection_in_hand");const{x:t,y:s}=r,n=o.selectedPiece.from==="hand"?o.pieces[o.selectedPiece.index]:P(e.grid,o.selectedPiece.position.x,o.selectedPiece.position.y);if(n===null)throw new Error("selected_piece_is_null");if(G(e.grid,t,s)>=Math.abs(n))throw new Error("destination_bigger_than_piece");return e.grid[r.y][r.x].push(n),o.selectedPiece.from==="hand"&&o.unselectableIndexes.add(o.selectedPiece.index),o.selectedPiece.from==="board"&&e.grid[o.selectedPiece.position.y][o.selectedPiece.position.x].pop(),o.selectedPiece=null,e.state.action="select1",e.state.player=e.state.player===1?2:1,x(e),0},p=(e,r,o)=>{o.from.from==="hand"?X(e,r,o.from.index):O(e,r,o.from.position),B(e,o.to)},J=(e,r)=>{const o=[];for(let t=0;t<3;t++)for(let s=0;s<3;s++){const n=G(e.grid,s,t);(!n||n<Math.abs(r))&&o.push({x:s,y:t})}return o},w=(e,r)=>L(e,r).reduce((t,s)=>{const n=R(e,r,s),l=J(e,n);for(const i of l)t.push({from:s,to:i});return t},[]),L=(e,r)=>{const o=r.pieces.map((t,s)=>s).filter(t=>!(r.unselectableIndexes.has(t)||t===1&&!r.unselectableIndexes.has(0)||t===3&&!r.unselectableIndexes.has(2)||t===5&&!r.unselectableIndexes.has(4))).map(t=>({index:t,from:"hand"}));for(let t=0;t<3;t++)for(let s=0;s<3;s++)d(e.grid,s,t)===r.player&&o.push({from:"board",position:{x:s,y:t}});return o},R=(e,r,o)=>{if(o.from==="board"){const t=e.grid[o.position.y][o.position.x];return t[t.length-1]}return r.pieces[o.index]},m=e=>{if(x(e),e.state.action==="winner")return e.state.player===1?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER;if(e.state.action==="draw")return Number.MAX_SAFE_INTEGER/2;const r=w(e,e.player1),o=w(e,e.player2);if(r.length===0&&o.length===0)return Number.MAX_SAFE_INTEGER/2;let t=0;const s=d(e.grid,1,1);return s===e.player1.player?t+=2:s===e.player2.player&&(t-=2),[d(e.grid,0,0),d(e.grid,2,0),d(e.grid,0,2),d(e.grid,2,2)].forEach(l=>{l!==null&&(t+=l!==null&&l===1?1:-1)}),t},A=(e,r,o)=>{let t=0;o.from.from==="board"&&(t+=10);const s=R(e,r,o.from);return t+=Math.abs(s),o.to.x===1&&o.to.y===1&&(t+=5),(o.to.x===0&&o.to.y===0||o.to.x===2&&o.to.y===0||o.to.x===0&&o.to.y===2||o.to.x===2&&o.to.y===2)&&(t+=3),t},N=(e,r,o,t,s)=>{const n=w(e,r);if(x(e),o===0||!n.length||["draw","winner"].includes(e.state.action))return{score:m(e),move:null};if(r.player===1){let c=Number.MIN_SAFE_INTEGER,a;for(const u of n){const f=_(e),y=v(f),M=h(f);p(f,y,u);const b=N(f,M,o-1,t,s);if((c===void 0||b.score>=c)&&(c=b.score,a={score:b.score,move:u}),c>s)break;t=Math.max(t,c)}if(!a)throw new Error("no_minmax_result");return a}let l=Number.MAX_SAFE_INTEGER,i;for(const c of n){const a=_(e),u=v(a),f=h(a);p(a,u,c);const y=N(a,f,o-1,t,s);if((l===void 0||y.score<=l)&&(l=y.score,i={score:y.score,move:c}),l<t)break;s=Math.min(s,l)}if(!i)throw new Error("no_minmax_result");return i},z=(e,r)=>{const o=N(e,r,3,Number.MIN_SAFE_INTEGER,Number.MAX_SAFE_INTEGER);if(!o.move)throw new Error("no_move_possible");const t=o.move;p(e,r,t)},I=(e,r,o,t,s)=>{const n=w(e,r);if(x(e),o===0||!n.length||["draw","winner"].includes(e.state.action))return{score:m(e),move:null};if(n.sort((c,a)=>A(e,r,a)-A(e,r,c)),r.player===1){let c=Number.MIN_SAFE_INTEGER,a;for(const u of n){const f=_(e),y=v(f),M=h(f);p(f,y,u);const b=I(f,M,o-1,t,s);if((c===void 0||b.score>=c)&&(c=b.score,a={score:b.score,move:u}),c>s)break;t=Math.max(t,c)}if(!a)throw new Error("no_minmax_result");return a}let l=Number.MAX_SAFE_INTEGER,i;for(const c of n){const a=_(e),u=v(a),f=h(a);p(a,u,c);const y=I(a,f,o-1,t,s);if((l===void 0||y.score<=l)&&(l=y.score,i={score:y.score,move:c}),l<t)break;s=Math.min(s,l)}if(!i)throw new Error("no_minmax_result");return i},U=(e,r)=>{const o=I(e,r,4,Number.MIN_SAFE_INTEGER,Number.MAX_SAFE_INTEGER);if(!o.move)throw new Error("no_move_possible");const t=o.move;p(e,r,t)},V=(e,r)=>{const o=w(e,r);if(!o.length)throw new Error("no_move_possible");const n=[...o.reduce((l,i)=>{const c=_(e),a=r.player===1?c.player1:c.player2;p(c,a,i);const u=m(c);return l.push({move:i,score:u}),l},[])].sort((l,i)=>r.player===1?i.score-l.score:l.score-i.score)[0].move;p(e,r,n)},S=(e,r,o)=>{const t=w(e,r);if(x(e),o===0||!t.length||["draw","winner"].includes(e.state.action))return{score:m(e),move:null};if(r.player===1){let s=Number.MIN_SAFE_INTEGER,n;for(const l of t){const i=_(e),c=v(i),a=h(i);p(i,c,l);const u=S(i,a,o-1);(s===void 0||u.score>=s)&&(s=u.score,n={score:u.score,move:l})}if(!n)throw new Error("no_minmax_result");return n}else{let s=Number.MAX_SAFE_INTEGER,n;for(const l of t){const i=_(e),c=v(i),a=h(i);p(i,c,l);const u=S(i,a,o-1);(s===void 0||u.score<=s)&&(s=u.score,n={score:u.score,move:l})}if(!n)throw new Error("no_minmax_result");return n}},W=(e,r)=>{const o=S(e,r,2);if(!o.move)throw new Error("no_move_possible");const t=o.move;p(e,r,t)},F=(e,r,o)=>{const t=r.player===1?1:-1,s=w(e,r);if(x(e),o===0||!s.length||["draw","winner"].includes(e.state.action))return{score:m(e)*t,move:null};let n=Number.MIN_SAFE_INTEGER,l;for(const i of s){const c=_(e),a=v(c),u=h(c);p(c,a,i);const f=F(c,u,o-1);f.score=-f.score,(n===void 0||f.score>=n)&&(n=f.score,l={score:f.score,move:i})}if(!l)throw new Error("no_minmax_result");return l},q=(e,r)=>{const o=F(e,r,2);if(!o.move)throw new Error("no_move_possible");const t=o.move;p(e,r,t)},k=(e,r)=>{const o=w(e,r);if(o.length===0)throw new Error("no_move_possible");const t=Math.floor(Math.random()*o.length),s=o[t];p(e,r,s)},D=(e,r)=>{const o=w(e,r);if(!o.length)throw new Error("no_move_possible");for(const t of o){const s=_(e),n=r.player===1?s.player1:s.player2;if(p(s,n,t),x(s),s.state.action==="winner"&&s.state.player===r.player){p(e,r,t);return}}k(e,r)},Y={random:k,win_or_random:D,euristic:V,minmax:W,negamax:q,alphabeta:z,alphabeta_ordered:U};export{v as a,h as b,O as c,X as d,x as e,T as f,K as g,$ as h,Q as i,B as p,Y as s};
