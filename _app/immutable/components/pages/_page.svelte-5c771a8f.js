import{S as Xa,i as Ya,s as Za,k as o,q as i,a as c,l as s,m as n,r,h as a,c as m,n as f,b as h,D as e,B as ha}from"../../chunks/index-5ee46145.js";function $a(Va){let g,Fe,Ie,M,Oe,xe,_,Re,q,De,je,Ae,u,z,te,Je,Ke,Qe,w,ae,Ve,Xe,L,Ye,Ze,$e,U,oe,et,tt,at,T,ie,ot,it,W,st,nt,Le,F,rt,Be,O,lt,Ge,R,ht,Se,v,D,ct,mt,B,pt,ft,He,j,dt,Pe,p,J,se,ut,bt,vt,K,ne,yt,gt,_t,E,re,wt,Tt,y,le,Et,kt,he,It,xt,ce,At,Lt,Bt,Q,me,Gt,St,Ht,k,pe,Pt,Nt,G,Ct,Mt,qt,fe,de,zt,Ut,S,Wt,Ft,V,ue,Ot,Rt,Ne,X,Dt,Ce,Y,jt,Me,I,Jt,Z,Kt,Qt,qe,$,Vt,ze,b,be,H,Xt,Yt,ve,P,Zt,$t,ye,N,ea,ta,ge,C,aa;return{c(){g=o("p"),Fe=i("This is my Tic Tac Toe based games playground"),Ie=c(),M=o("h2"),Oe=i("Tic Tac Toe"),xe=c(),_=o("p"),Re=i("The "),q=o("a"),De=i("Tic Tac Toe"),je=i(` page is a implementation of the classical Tic Tac Toe game.
    The "Game" section allows a player to play against different AI opponent. Buttons also allow the
    player to use one of the AIs to play their move.`),Ae=c(),u=o("ul"),z=o("li"),te=o("b"),Je=i("random"),Ke=i(" is a dumb AI where the next move is chosen randomly amongst the valid moves"),Qe=c(),w=o("li"),ae=o("b"),Ve=i("hardcodedrules"),Xe=i(` is a strategy based on
        `),L=o("a"),Ye=i("Newell and Simon's 1972 tic-tac-toe program"),Ze=i(` as described on Wikipedia. This version does not look for move creating forks or blocking
        the opponent's forks making it easy to beat.`),$e=c(),U=o("li"),oe=o("b"),et=i("hardcodedrulesComplete"),tt=i(` is based on the previous strategy but it also checks for forks
        and try to block opponent's fork. However my implementation of this last check is not complete
        and thus the AI is not perfect, it can lose some games.`),at=c(),T=o("li"),ie=o("b"),ot=i("minmax"),it=i(` is an implementation of
        `),W=o("a"),st=i("the minmax algorith"),nt=i(` is according to my tests
        it is a perfect opponent which never loses.`),Le=c(),F=o("p"),rt=i(`The "Generator" section can be used to make the AIs play several games against each other. The
    interesting use case is to compare the performances of the different AIs against a random
    player. This is by this means that I empirically determined that my hard coded rules strategies
    are not perfect unlike my minmax strategy.`),Be=c(),O=o("p"),lt=i(`The "Analyzer" section is used for debugging and writting tests. It allows the users to create
    any tic tac toe board and visualize some information like the bynary representation of each
    player's move`),Ge=c(),R=o("h2"),ht=i("Gobblet"),Se=c(),v=o("p"),D=o("a"),ct=i("Gobblet"),mt=i(` is a tic tac toe game with pieces of different dimensions,
    inspired by `),B=o("a"),pt=i("Gobblet"),ft=i(` played
    on a 3x3 board. Players take turns to place a piece on the board or move their piece that already
    is on the board. Bigger pieces can be placed so that they cover smaller ones and a player wins by
    aligning 3 pieces.`),He=c(),j=o("p"),dt=i(`In the "Game" section you can play against different level of AIs. None of them are perfect.
    Buttons allow the player to use one of the AIs to play their move.`),Pe=c(),p=o("ul"),J=o("li"),se=o("b"),ut=i("random"),bt=i(" is a simple random AI which choose one of the possible moves."),vt=c(),K=o("li"),ne=o("b"),yt=i("win_or_random"),gt=i(` Checks all the possible moves it can do, if one of them creates a win for
        the AI then it plays it otherwise it plays a random move amongst the possible ones.`),_t=c(),E=o("li"),re=o("b"),wt=i("euristic"),Tt=i(` makes a very simple choice based on the euristic value of the next move.
        `),y=o("ul"),le=o("li"),Et=i("For the current state compute all the possible moves."),kt=c(),he=o("li"),It=i("Score each move with a euristic"),xt=c(),ce=o("li"),At=i("Select the move with the highest score"),Lt=i(`
        This strategy is not very good because it doesn't consider the future It will only play a winning
        move if one is possible. Since it doesn't check the next opponent's move it sometimes play losing
        moves. However since the euristic favorise more interesting cells (center and corners) it is
        a bit better than the win_or_random strat`),Bt=c(),Q=o("li"),me=o("b"),Gt=i("minmax"),St=i(` is a classical minmax strategy. No pruning is implemented so the max depth is set
        to 2 because for higher depths the response time gets quite long.`),Ht=c(),k=o("li"),pe=o("b"),Pt=i("negamax"),Nt=i(` is an implementation of the
        `),G=o("a"),Ct=i("negamax algorithm"),Mt=i(`. As
        expected it yields the same results as the minmax strategy but its code is simpler. The
        performance remains the same as minmax with the same max depth.`),qt=c(),fe=o("li"),de=o("b"),zt=i("alphabeta"),Ut=i(`
    is an incomplete
    `),S=o("a"),Wt=i(`minmax with alphabeta pruning strategy
    `),Ft=i(`. Here the children are not ordered via an evaluation fonction, the children are ordered in
    a consistent but random order. That makes the alpha-beta pruning unefficient and it only improve
    the performance to allow a depth of 3.
    `),V=o("li"),ue=o("b"),Ot=i("alphabeta_with_order"),Rt=i(` aims to fix the previous solution by ordering the children depending
        on a score attributed by a custom evaluation function. However the implementation is incomplete
        and probably buggy so the AI is not perfect.`),Ne=c(),X=o("p"),Dt=i(`The "Runner" section allows to make the AIs play games against each other and get statistics of
    these games.`),Ce=c(),Y=o("h2"),jt=i("Misere"),Me=c(),I=o("p"),Jt=i("The "),Z=o("a"),Kt=i("Misere"),Qt=i(` page a variant of Tic Tac Toe where the player wins if the opponent
    aligns 3 pieces. The "Game" section allows a player to play against different AI opponent. Only the
    random and minmax are implemented because they reused the code of the regular Tic Tac Toe AI.`),qe=c(),$=o("h2"),Vt=i("Some interesting readings:"),ze=c(),b=o("ul"),be=o("li"),H=o("a"),Xt=i("Tic Tac Toe variants on Wikipedia"),Yt=c(),ve=o("li"),P=o("a"),Zt=i("Gobblet rules"),$t=c(),ye=o("li"),N=o("a"),ea=i("Bitwise operations for tic tac toe"),ta=c(),ge=o("li"),C=o("a"),aa=i("Evolution of No-loss Strategies for the Game of Tic-Tac-Toe"),this.h()},l(t){g=s(t,"P",{});var l=n(g);Fe=r(l,"This is my Tic Tac Toe based games playground"),l.forEach(a),Ie=m(t),M=s(t,"H2",{});var ca=n(M);Oe=r(ca,"Tic Tac Toe"),ca.forEach(a),xe=m(t),_=s(t,"P",{});var Ue=n(_);Re=r(Ue,"The "),q=s(Ue,"A",{href:!0});var ma=n(q);De=r(ma,"Tic Tac Toe"),ma.forEach(a),je=r(Ue,` page is a implementation of the classical Tic Tac Toe game.
    The "Game" section allows a player to play against different AI opponent. Buttons also allow the
    player to use one of the AIs to play their move.`),Ue.forEach(a),Ae=m(t),u=s(t,"UL",{});var x=n(u);z=s(x,"LI",{});var oa=n(z);te=s(oa,"B",{});var pa=n(te);Je=r(pa,"random"),pa.forEach(a),Ke=r(oa," is a dumb AI where the next move is chosen randomly amongst the valid moves"),oa.forEach(a),Qe=m(x),w=s(x,"LI",{});var _e=n(w);ae=s(_e,"B",{});var fa=n(ae);Ve=r(fa,"hardcodedrules"),fa.forEach(a),Xe=r(_e,` is a strategy based on
        `),L=s(_e,"A",{href:!0,target:!0});var da=n(L);Ye=r(da,"Newell and Simon's 1972 tic-tac-toe program"),da.forEach(a),Ze=r(_e,` as described on Wikipedia. This version does not look for move creating forks or blocking
        the opponent's forks making it easy to beat.`),_e.forEach(a),$e=m(x),U=s(x,"LI",{});var ia=n(U);oe=s(ia,"B",{});var ua=n(oe);et=r(ua,"hardcodedrulesComplete"),ua.forEach(a),tt=r(ia,` is based on the previous strategy but it also checks for forks
        and try to block opponent's fork. However my implementation of this last check is not complete
        and thus the AI is not perfect, it can lose some games.`),ia.forEach(a),at=m(x),T=s(x,"LI",{});var we=n(T);ie=s(we,"B",{});var ba=n(ie);ot=r(ba,"minmax"),ba.forEach(a),it=r(we,` is an implementation of
        `),W=s(we,"A",{href:!0});var va=n(W);st=r(va,"the minmax algorith"),va.forEach(a),nt=r(we,` is according to my tests
        it is a perfect opponent which never loses.`),we.forEach(a),x.forEach(a),Le=m(t),F=s(t,"P",{});var ya=n(F);rt=r(ya,`The "Generator" section can be used to make the AIs play several games against each other. The
    interesting use case is to compare the performances of the different AIs against a random
    player. This is by this means that I empirically determined that my hard coded rules strategies
    are not perfect unlike my minmax strategy.`),ya.forEach(a),Be=m(t),O=s(t,"P",{});var ga=n(O);lt=r(ga,`The "Analyzer" section is used for debugging and writting tests. It allows the users to create
    any tic tac toe board and visualize some information like the bynary representation of each
    player's move`),ga.forEach(a),Ge=m(t),R=s(t,"H2",{});var _a=n(R);ht=r(_a,"Gobblet"),_a.forEach(a),Se=m(t),v=s(t,"P",{});var Te=n(v);D=s(Te,"A",{href:!0});var wa=n(D);ct=r(wa,"Gobblet"),wa.forEach(a),mt=r(Te,` is a tic tac toe game with pieces of different dimensions,
    inspired by `),B=s(Te,"A",{href:!0,target:!0});var Ta=n(B);pt=r(Ta,"Gobblet"),Ta.forEach(a),ft=r(Te,` played
    on a 3x3 board. Players take turns to place a piece on the board or move their piece that already
    is on the board. Bigger pieces can be placed so that they cover smaller ones and a player wins by
    aligning 3 pieces.`),Te.forEach(a),He=m(t),j=s(t,"P",{});var Ea=n(j);dt=r(Ea,`In the "Game" section you can play against different level of AIs. None of them are perfect.
    Buttons allow the player to use one of the AIs to play their move.`),Ea.forEach(a),Pe=m(t),p=s(t,"UL",{});var d=n(p);J=s(d,"LI",{});var sa=n(J);se=s(sa,"B",{});var ka=n(se);ut=r(ka,"random"),ka.forEach(a),bt=r(sa," is a simple random AI which choose one of the possible moves."),sa.forEach(a),vt=m(d),K=s(d,"LI",{});var na=n(K);ne=s(na,"B",{});var Ia=n(ne);yt=r(Ia,"win_or_random"),Ia.forEach(a),gt=r(na,` Checks all the possible moves it can do, if one of them creates a win for
        the AI then it plays it otherwise it plays a random move amongst the possible ones.`),na.forEach(a),_t=m(d),E=s(d,"LI",{});var Ee=n(E);re=s(Ee,"B",{});var xa=n(re);wt=r(xa,"euristic"),xa.forEach(a),Tt=r(Ee,` makes a very simple choice based on the euristic value of the next move.
        `),y=s(Ee,"UL",{});var ee=n(y);le=s(ee,"LI",{});var Aa=n(le);Et=r(Aa,"For the current state compute all the possible moves."),Aa.forEach(a),kt=m(ee),he=s(ee,"LI",{});var La=n(he);It=r(La,"Score each move with a euristic"),La.forEach(a),xt=m(ee),ce=s(ee,"LI",{});var Ba=n(ce);At=r(Ba,"Select the move with the highest score"),Ba.forEach(a),ee.forEach(a),Lt=r(Ee,`
        This strategy is not very good because it doesn't consider the future It will only play a winning
        move if one is possible. Since it doesn't check the next opponent's move it sometimes play losing
        moves. However since the euristic favorise more interesting cells (center and corners) it is
        a bit better than the win_or_random strat`),Ee.forEach(a),Bt=m(d),Q=s(d,"LI",{});var ra=n(Q);me=s(ra,"B",{});var Ga=n(me);Gt=r(Ga,"minmax"),Ga.forEach(a),St=r(ra,` is a classical minmax strategy. No pruning is implemented so the max depth is set
        to 2 because for higher depths the response time gets quite long.`),ra.forEach(a),Ht=m(d),k=s(d,"LI",{});var ke=n(k);pe=s(ke,"B",{});var Sa=n(pe);Pt=r(Sa,"negamax"),Sa.forEach(a),Nt=r(ke,` is an implementation of the
        `),G=s(ke,"A",{href:!0,target:!0});var Ha=n(G);Ct=r(Ha,"negamax algorithm"),Ha.forEach(a),Mt=r(ke,`. As
        expected it yields the same results as the minmax strategy but its code is simpler. The
        performance remains the same as minmax with the same max depth.`),ke.forEach(a),qt=m(d),fe=s(d,"LI",{});var Pa=n(fe);de=s(Pa,"B",{});var Na=n(de);zt=r(Na,"alphabeta"),Na.forEach(a),Pa.forEach(a),Ut=r(d,`
    is an incomplete
    `),S=s(d,"A",{href:!0,target:!0});var Ca=n(S);Wt=r(Ca,`minmax with alphabeta pruning strategy
    `),Ca.forEach(a),Ft=r(d,`. Here the children are not ordered via an evaluation fonction, the children are ordered in
    a consistent but random order. That makes the alpha-beta pruning unefficient and it only improve
    the performance to allow a depth of 3.
    `),V=s(d,"LI",{});var la=n(V);ue=s(la,"B",{});var Ma=n(ue);Ot=r(Ma,"alphabeta_with_order"),Ma.forEach(a),Rt=r(la,` aims to fix the previous solution by ordering the children depending
        on a score attributed by a custom evaluation function. However the implementation is incomplete
        and probably buggy so the AI is not perfect.`),la.forEach(a),d.forEach(a),Ne=m(t),X=s(t,"P",{});var qa=n(X);Dt=r(qa,`The "Runner" section allows to make the AIs play games against each other and get statistics of
    these games.`),qa.forEach(a),Ce=m(t),Y=s(t,"H2",{});var za=n(Y);jt=r(za,"Misere"),za.forEach(a),Me=m(t),I=s(t,"P",{});var We=n(I);Jt=r(We,"The "),Z=s(We,"A",{href:!0});var Ua=n(Z);Kt=r(Ua,"Misere"),Ua.forEach(a),Qt=r(We,` page a variant of Tic Tac Toe where the player wins if the opponent
    aligns 3 pieces. The "Game" section allows a player to play against different AI opponent. Only the
    random and minmax are implemented because they reused the code of the regular Tic Tac Toe AI.`),We.forEach(a),qe=m(t),$=s(t,"H2",{});var Wa=n($);Vt=r(Wa,"Some interesting readings:"),Wa.forEach(a),ze=m(t),b=s(t,"UL",{});var A=n(b);be=s(A,"LI",{});var Fa=n(be);H=s(Fa,"A",{href:!0,target:!0});var Oa=n(H);Xt=r(Oa,"Tic Tac Toe variants on Wikipedia"),Oa.forEach(a),Fa.forEach(a),Yt=m(A),ve=s(A,"LI",{});var Ra=n(ve);P=s(Ra,"A",{href:!0,target:!0});var Da=n(P);Zt=r(Da,"Gobblet rules"),Da.forEach(a),Ra.forEach(a),$t=m(A),ye=s(A,"LI",{});var ja=n(ye);N=s(ja,"A",{href:!0,target:!0});var Ja=n(N);ea=r(Ja,"Bitwise operations for tic tac toe"),Ja.forEach(a),ja.forEach(a),ta=m(A),ge=s(A,"LI",{});var Ka=n(ge);C=s(Ka,"A",{href:!0,target:!0});var Qa=n(C);aa=r(Qa,"Evolution of No-loss Strategies for the Game of Tic-Tac-Toe"),Qa.forEach(a),Ka.forEach(a),A.forEach(a),this.h()},h(){f(q,"href","/tictactoe"),f(L,"href","https://en.wikipedia.org/wiki/Tic-tac-toe#Strategy"),f(L,"target","noopener"),f(W,"href","https://en.wikipedia.org/wiki/Minimax"),f(D,"href","/gobblet"),f(B,"href","https://en.wikipedia.org/wiki/Gobblet"),f(B,"target","noopener"),f(G,"href","https://en.wikipedia.org/wiki/Negamax"),f(G,"target","noopener"),f(S,"href","https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning"),f(S,"target","noopener"),f(Z,"href","/misere"),f(H,"href","https://en.wikipedia.org/wiki/Tic-tac-toe_variants"),f(H,"target","noopener"),f(P,"href","https://docs.racket-lang.org/games/gobblet.html"),f(P,"target","noopener"),f(N,"href","https://rclayton.silvrback.com/winner-in-tic-tac-toe"),f(N,"target","noopener"),f(C,"href","https://www.egr.msu.edu/~kdeb/papers/k2007002.pdf"),f(C,"target","noopener")},m(t,l){h(t,g,l),e(g,Fe),h(t,Ie,l),h(t,M,l),e(M,Oe),h(t,xe,l),h(t,_,l),e(_,Re),e(_,q),e(q,De),e(_,je),h(t,Ae,l),h(t,u,l),e(u,z),e(z,te),e(te,Je),e(z,Ke),e(u,Qe),e(u,w),e(w,ae),e(ae,Ve),e(w,Xe),e(w,L),e(L,Ye),e(w,Ze),e(u,$e),e(u,U),e(U,oe),e(oe,et),e(U,tt),e(u,at),e(u,T),e(T,ie),e(ie,ot),e(T,it),e(T,W),e(W,st),e(T,nt),h(t,Le,l),h(t,F,l),e(F,rt),h(t,Be,l),h(t,O,l),e(O,lt),h(t,Ge,l),h(t,R,l),e(R,ht),h(t,Se,l),h(t,v,l),e(v,D),e(D,ct),e(v,mt),e(v,B),e(B,pt),e(v,ft),h(t,He,l),h(t,j,l),e(j,dt),h(t,Pe,l),h(t,p,l),e(p,J),e(J,se),e(se,ut),e(J,bt),e(p,vt),e(p,K),e(K,ne),e(ne,yt),e(K,gt),e(p,_t),e(p,E),e(E,re),e(re,wt),e(E,Tt),e(E,y),e(y,le),e(le,Et),e(y,kt),e(y,he),e(he,It),e(y,xt),e(y,ce),e(ce,At),e(E,Lt),e(p,Bt),e(p,Q),e(Q,me),e(me,Gt),e(Q,St),e(p,Ht),e(p,k),e(k,pe),e(pe,Pt),e(k,Nt),e(k,G),e(G,Ct),e(k,Mt),e(p,qt),e(p,fe),e(fe,de),e(de,zt),e(p,Ut),e(p,S),e(S,Wt),e(p,Ft),e(p,V),e(V,ue),e(ue,Ot),e(V,Rt),h(t,Ne,l),h(t,X,l),e(X,Dt),h(t,Ce,l),h(t,Y,l),e(Y,jt),h(t,Me,l),h(t,I,l),e(I,Jt),e(I,Z),e(Z,Kt),e(I,Qt),h(t,qe,l),h(t,$,l),e($,Vt),h(t,ze,l),h(t,b,l),e(b,be),e(be,H),e(H,Xt),e(b,Yt),e(b,ve),e(ve,P),e(P,Zt),e(b,$t),e(b,ye),e(ye,N),e(N,ea),e(b,ta),e(b,ge),e(ge,C),e(C,aa)},p:ha,i:ha,o:ha,d(t){t&&a(g),t&&a(Ie),t&&a(M),t&&a(xe),t&&a(_),t&&a(Ae),t&&a(u),t&&a(Le),t&&a(F),t&&a(Be),t&&a(O),t&&a(Ge),t&&a(R),t&&a(Se),t&&a(v),t&&a(He),t&&a(j),t&&a(Pe),t&&a(p),t&&a(Ne),t&&a(X),t&&a(Ce),t&&a(Y),t&&a(Me),t&&a(I),t&&a(qe),t&&a($),t&&a(ze),t&&a(b)}}}class to extends Xa{constructor(g){super(),Ya(this,g,null,$a,Za,{})}}export{to as default};
